# Билет 11
## Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.
###  Модели ветвления (branching model)
#### Feature branches
![](./pictures/topic-branches-1.png)
* Для каждой более-менее крупной фичи создается отдельная ветка, на которой она разрабатывается параллельно основной разработке проекта. Затем фича вливается в ветку development или сразу в master

#### GitFlow
![](./pictures/git-flow-updated.png)

Пояснения к схеме:

* Есть две основные ветки: master и develop.
* В ветке master содержится ровно тот же код, что и в рабочей версии проекта. А вся работа делается в ветке develop.
* Во время работы на основе develop создаются так называемые feature-ветки. Их может быть неограниченное количество.
* Далее, у нас есть ветка release, которая используется для подготовки к новому релизу проекта.

* Наконец, есть ветка hotfix, которая служит для срочного исправления багов, найденных, например, на продакте.

Рабочий процесс в Gitflow:

1. Создается репозиторий
2. Репозиторий инициализируется
3. Начинается работа на ветке develop
4. Возникает необходимость опробовать новую штуку – создается feature-ветка и делаются коммиты
5. Закончив работу на feature-ветке, вы сливаете ее с develop
6. Если вы довольны текущей версией, но хотите продолжить работу, создается ветка release, куда перемещается текущая версия. Правка багов будет происходить на этой же ветке.
7. Когда с веткой release покончено, время слить ее в master и продолжить работу с develop
8. Кроме того, этот момент можно отметить на master-ветке

#### GitHub Flow
![](./pictures/github-flow.png)

Рабочий процесс в GitHub:

* Содержимое ветви master всегда работоспособно (deployable).
* Начиная работу над чем-то новым, ответвляйте от ветви master новую ветвь, имя которой соответствует её предназначению (например, «new-oauth2-scopes»).
* Закоммитив в эту ветвь локально, отправляйте регулярно свою работу и в одноимённую ветвь на сервере.
* Когда вам понадобится отзыв, или помощь, или когда вы сочтёте ветвь готовою ко слиянию, отправьте запрос на слияние.
* После того, как кто-то другой просмотрел и одобрил фичу, вы можете слить вашу ветвь в ветвь master.
* После того, как ветвь master пополнилась новым кодом, вы можете немедленно внедрить его на продакшен и вам следует сделать это.

### Распределенные рабочие процессы (workflow)
#### Centralized
![](./pictures/centralized-workflow.png)
* Существует один репозиторий, в который каждый разработчик имеет право заливать изменения прямо в ветку master
* Состоятелен для маленьких команд (<10 человек), особенно если все разработчики находятся в одном помещении
* Главным минусом подхода являются merge conflicts, ситуации, когда одни и те же файлы были изменены разными разработчиками и один и тот же файл пытаются залить в master

Централизованный рабочий процесс

В централизованных системах существует, как правило, одна модель совместной разработки — централизованный рабочий процесс. Один центральный хаб, или репозиторий, может принимать код, а все остальные синхронизируют свою работу с ним. Некоторое число разработчиков являются узлами — клиентами этого хаба — и синхронизируются с ним одним.

Это значит, что если два разработчика выполняют клонирование с хаба и оба делают изменения в проекте, то первый из них, кто отправит свои изменения обратно на хаб, сделает это без проблем. Второй разработчик должен взять наработки первого и выполнить слияние перед тем, как отправить свои изменения, так чтобы не перезаписать изменения первого разработчика. Этот принцип справедлив для Git'а точно так же, как и для Subversion (или любой другой ЦСКВ), и в Git'е такая модель работает отлично.

Если у вас небольшая команда или вас полностью устраивает рабочий процесс централизованного типа, применяемый в вашей компании, вы можете просто продолжить использовать такой рабочий процесс и в Git'е. Просто настройте один репозиторий и дайте каждому в вашей команде права на отправку изменений; Git не позволит пользователям перезаписывать наработки друг друга. Если какой-то разработчик склонирует репозиторий, сделает в нём изменения, а затем попытается выложить эти изменения, в то время как другой разработчик уже успел отправить свои, сервер отклонит изменения этого разработчика. Ему будет сказано, что он пытается выложить изменения, для которых невозможно выполнить перемотку (fast-forward), и что надо сначала извлечь данные с сервера, выполнить слияние, а уже потом отправлять свои изменения. Такой рабочий процесс привлекателен для большого количества людей, так как это та модель, с которой многие знакомы и которая многим понятна.

#### Integration Manager
![](./pictures/integration-manager-workflow.png)
* Подходит для больших и средних команд
* Каждый разрботчик имеет свою копию главного репозитория, в которую только он может заливать файлы
* Для внесения изменений в главный репозиторий разработчик посылает пулл запрос
* Пулл запрос рецензируется integration manager'ом и другими разработчиками
* После получения одобрения от integration manager'а изменения вливаются в ветку master
* Merge conflict крайне маловероятны благодаря наличию integration manager'а
* Пулл запросы могут проверяться значительное время в зависимости от загруженности integration manager'а
* Крайне важен выбор integration manager'а 

Рабочий процесс с менеджером по интеграции

Так как Git позволяет иметь несколько удалённых репозиториев, существует возможность ведения такого рабочего процесса, при котором каждый разработчик имеет права на запись в свой собственный публичный репозиторий и права на чтение для всех остальных. Этот сценарий часто подразумевает существование канонического репозитория, который представляет собой "официальный" проект. Чтобы принять участие в работе над этим проектом, надо создать свою собственную публичную копию проекта и выложить туда свои изменения. Потом вы можете отправить запрос владельцу основного проекта на внесение в него ваших изменений. Он может добавить ваш репозиторий в качестве удалённого, протестировать локально ваши изменения, слить их со своей веткой и затем отправить обратно в публичный репозиторий. Этот процесс осуществляется следующим образом:

1. Владелец проекта выкладывает файлы в публичный репозиторий.

2. Участники проекта клонируют этот репозиторий и делают изменения.

3. Участники выкладывают изменения в свои собственные публичные репозитории.

4. Участник проекта отправляет владельцу письмо с просьбой включения его изменений.

5. Владелец проекта добавляет репозиторий участника как удалённый и локально выполняет слияние.

6. Владелец отправляет слитые изменения в основной репозиторий.

Это очень распространённый тип рабочего процесса для сайтов вроде GitHub, где можно легко форкнуть проект и выложить свои изменения на всеобщее обозрение в собственную копию. Одно из главных преимуществ такого подхода — возможность продолжать работать, в то время как владелец основного репозитория может включить себе ваши изменения, когда ему угодно. Участникам проекта не придётся ждать включения своих изменений в проект — каждый может работать в своём собственном ритме.

#### Dictator and Lieutenants
![](./pictures/dictator-and-lieutenants-orkflow.png)
* Идеально подходит для open-source проектов с главенствующей ролью создателя проекта
* Является расширением integration manager workflow
* В проекте выделяется диктатор с эксклюзивными правами записи в главный репозиторий, и лейтенанты, контролирующие отдельные аспекты проекта
* Разработчики посылают изменения на проверку лейтенантам
* После одобрения изменений лейтенанты посылают эти изменения диктатору на одобрение
* Плюсом является крайняя степнь контроля качества проекта
* Минусом - процесс проверки и одобрения изменений может сильно затянуться

Рабочий процесс с диктатором и его помощниками

Это одна из разновидностей рабочего процесса с множеством репозиториев. В основном он используется в огромных проектах с сотнями участников; ядро Linux — яркий тому пример. Несколько менеджеров по интеграции заведуют разными частями репозитория; этих людей называют помощниками. У всех этих помощников есть только один менеджер по интеграции, которого называют благосклонным диктатором. Репозиторий

благосклонного диктатора служит эталонным репозиторием, откуда все участники проекта должны брать изменения. Этот процесс происходит так:

1. Обычные разработчики работают над своими тематическими ветками и перемещают свою работу на вершину ветки master. Ветка master — это та ветка, которая находится у диктатора.

2. Помощники сливают тематические ветки разработчиков в свои ветки master.

3. Диктатор выполняет слияние веток master своих помощников со своей веткой master.

4. Диктатор отправляет свою ветку master в эталонный репозиторий, чтобы остальные разработчики могли выполнять перемещение на неё.

Этот тип рабочего процесса не является распространённым, но он может быть полезен в очень больших проектах или в сильно иерархическом окружении, так как он позволяет лидеру проекта (диктатору) передать другим полномочия по выполнению большой части работ и собирать код большими порциями с нескольких мест перед его интеграцией.

Мы рассмотрели несколько широко используемых типов рабочих процессов, доступных при работе с распределёнными системами вроде Git'а, но, как видите, возможны различные вариации для подгонки под ваш конкретный тип рабочего процесса. Теперь, когда вы в состоянии определить, какая комбинация рабочих процессов сработает для вас лучше, мы рассмотрим несколько более специфичных примеров действий, выполняемых основными ролями участников различных процессов

***
***
***

## Статическая и динамическая компоновка. Сравнительный анализ.
### Статическая компоновка

При использовании статической компоновки готовится исходный текст приложения, затем транслируется для получения объектного модуля. После этого редактор связей компоновал объектные модули, полученные в результате трансляции исходных текстов и модули из библиотек объектных модулей, в один исполнимый exe-файл. В процессе запуска файл программы загружался полностью в оперативную память и ему передавалось управление.

Таким образом, при использовании статической компоновки редактор связей записывает в файл программы все модули, необходимые для работы. В любой момент времени в оперативной памяти компьютера находится весь код, необходимый для работы запущенной программы.

В среде мультизадачной операционной системы статическая компоновка неэффективна, так как приводит к неэкономному использованию оперативной памяти. Представьте себе, что в системе одновременно работают 5 приложений, и все они вызывают одну функцию. Если приложения были собраны с использованием статической компоновки, в памяти будут находится одновременно 5 копий функции этой функции.

Очевидно, использование оперативной памяти было бы намного эффективнее, если бы в памяти находилось только по одной копии функций, а все работающие параллельно программы могли бы их вызывать.

Практически в любой многозадачной операционной системе для любого компьютера используется именно такой способ обращения к функциям, нужным одновременно большому количеству работающих параллельно программ.

* Готовится исходный текст приложения
* Затем транслируется для получения объектного модуля
* После этого редактор связей компонует объектные модули, полученные в результате трансляции исходных текстов и модули из библиотек объектных модулей, в один исполняемый файл
    * В файл записываются все модули, необходимые для работы
* В процессе запуска файл программы загружается полностью в оперативную память и ему передавается управление.
    * В любой момент времени в оперативной памяти компьютера находится весь код, необходимый для работы запущенной программы
* Все функции находятся внутри выполняемого модуля;
* Все адреса переменных и функций определяются на этапе компиляции;
* "Нет зависимости" от других библиотек.

Недостатки:
* Неэкономное использование оперативной памяти.

### Динамическая компоновка

При использовании динамической компоновки загрузочный код нескольких (или нескольких десятков) функций объединяется в отдельные файлы, загружаемые в оперативную память в единственном экземпляре. Программы, работающие параллельно, вызывают функции, загруженные в память из файлов библиотек динамической компоновки, а не из файлов программ.

Таким образом, используя механизм динамической компоновки, в загрузочном файле программы можно расположить только те функции, которые являются специфическими для данной программы. Те же функции, которые нужны всем (или многим) программам, работающим параллельно, можно вынести в отдельные файлы - библиотеки динамической компоновки, и хранить в памяти в единственном экземпляре (рис. 3.2). Эти файлы можно загружать в память только при необходимости, например, когда какая-нибудь программа захочет вызвать функцию, код которой расположен в библиотеке.

В операционной системе Windows NT файлы библиотек динамической компоновки имеют расширение имени dll, хотя можно использовать любое другое, например, exe. В первых версиях Windows DLL-библиотеки располагались в файлах с расширением имени exe. Возможно поэтому файлы krnl286.exe, krnl386.exe, gdi.exe и user.exe имели расширение имени exe, а не dll, несмотря на то, что перечисленные выше файлы, составляющие ядро операционной системы Windows версии 3.1, есть ни что иное, как DLL-библиотеки. Наиболее важные компоненты операционной системы Microsoft Windows NT расположены в библиотеках с именами kernel32.dll (ядро операционной системы), user32.dll (функции пользовательского интерфейса), gdi32.dll XE "gdi32.dll" (функции для рисования изображений и текста).

Механизм динамической компоновки был изобретен задолго до появления операционных систем Windows и OS/2 (которая также активно использует механизм динамической компоновки). Например, в мультизадачных многопользовательских операционных системах VS1, VS2, MVS, VM, созданных для компьютеров IBM-370 и аналогичных, код функций, нужных параллельно работающим программам, располагается в отдельных библиотеках и может загружаться при необходимости в специально выделенную общую область памяти.

* Загрузочный код нескольких функций объединяется в отдельные файлы, загружаемые в оперативную память в единственном экземпляре
    * В загрузочном файле программы можно расположить только те функции, которые являются специфическими для данной программы
    * Функции, необходимые всем (или многим) программам, работающим параллельно,выносятся в библиотеки динамической компоновки, и хранятся в памяти в единственном экземпляре
* Программы, работающие параллельно, вызывают функции, загруженные в память из файлов библиотек динамической компоновки, а не из файлов программ

* Компоновка исполняемого модуля во время исполнения;
* Библиотечные функции находятся в других модулях;
* Связывание происходит во время выполнения путём заполнения таблиц адресов;
* Явная зависимость от других библиотек.

Статическая компановка - получается один большой файл, куда всё включено.
Динамическая компановка - есть "таблица экспорта (что нужно отдать) и импорта(что нужно взять (от чего зависит)). Получается наш файл явно зависит от других библиотек.

Файлы исходного кода содержат алгоритмы и компилируются непосредственно в команды процессора в виде объектных файлов (*.obj), по одному на каждый файл исходного кода. Чтобы собрать объектные файлы в один двоичный файл (непосредственно исполняемый *.exe, или библиотеки *.dll (*.so для Linux), *.lib) необходимо произвести линковку. Этим занимается программа Linker (компоновщик, линкер), ориентируясь по хэдерам.

Линковка может быть статическая и динамическая. Статическая представляет собой собрание *.obj-файлов библиотеки в *.lib, который мы можем, указав линкеру, прицепить к нашей программе в момент компиляции. Содержимоей библиотеки, как всегда, описывается в хэдерах, которые распространяются вместе с *.lib . На выходе мы получим одинокий исполняемый файл вашей программы (*.exe).

Динамическая линковка выполняется средствами платформы (операционной системы) в процессе работы программы. Все так же у нас в руках *.lib и *.h файлы, однако, теперь к ним добавляется *.dll (*.so для Linux). *.lib-файл теперь содержит только вызовы к *.dll, где лежат непосредственно алгоритмы и которые вызываются уже на ходу, а не компилируются. Потому теперь у нас *.exe + *.dll . Несколько программ могут использовать один *.dll одновременно, тем самым не занимая оперативную память одинаковыми кусками и сами программы меньше размером. Так, например, работают многие драйверы и графические библиотеки (DirectX и OpenGL). Однако, сейчас это не такая актуальная проблема, тянут недостатки - несовместимости версий, отсутствие нужных библиотек, ад зависимостей для установки приложений (работая в Linux с графическим окружением Gnome (основанной на библиотеке GTK+) если скачать малюсенький текстовый редактор Kate для ГО KDE (основанной на Qt), то придется тянуть этот-самый Qt на десятки мегобайт). Потому, сейчас рекомендуют не увлекаться динамической линковкой и стараться связывать программы статически.

Для связывания модулей компоновщик использует таблицы символов, созданные компилятором в каждом из объектных модулей.

Для большинства компиляторов, один объектный файл является результатом компиляции одного файла с исходным кодом. Если программа собирается из нескольких объектных файлов, компоновщик собирает эти файлы в единый исполнимый модуль, вычисляя и подставляя адреса вместо символов, в течение времени компоновки (статическая компоновка) или во время исполнения (динамическая компоновка).

Компоновщик может извлекать объектные файлы из специальных коллекций, называемых библиотеками. Если не все символы, на которые ссылаются пользовательские объектные файлы, определены, то компоновщик ищет их определения в библиотеках, которые пользователь подал ему на вход. Обычно, одна или несколько системных библиотек используются компоновщиком по умолчанию. Когда объектный файл, в котором содержится определение какого-либо искомого символа, найден, компоновщик может включить его (файл) в исполнимый модуль (в случае статической компоновки) или отложить это до момента запуска программы (в случае динамической компоновки).

Работа компоновщика заключается в том, чтобы в каждом модуле определить и связать ссылки на неопределённые имена. Для каждого импортируемого имени находится его определение в других модулях, упоминание имени заменяется на его адрес.